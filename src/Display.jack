// Hackenstein-3D: Escape from Castle Hackenstein part 2
// by James Leibert February 2017

// Display module handles the following services:
// ... rendering the walls with the correct textures and heights
// ... rendering the bitmaps
// ... rendering text to the screen

class Display {

    // Bitmaps for the sights and pistol
    static Array sc, sf, pc, pf;

    // Bit-masks to simplify rendering
    static Array patternMask;


    // Display strings
    // Note that the OS implementation leaks memory, so we have to
    // pre-initialise the strings
    static String stepStr, targetStr, text1, text2, text3;

    // Screen location for rendering
    static int screenLocation;

    // 8 pattern strip counters for rendering
    // ... cp is pattern segment counter
    // ... sp is the current pattern segment (0-7)
    // ... pt is the pattern mask for the top segment
    // ... pb is the pattern mask for the bottom segment
    // ... pp is the bit-mask for the bottom segment
    // ... wp is the pattern word for this pixel
    // ... wd is the distance word for this pixel
    static int cp0, cp1, cp2, cp3, cp4, cp5, cp6, cp7;
    static int sp0, sp1, sp2, sp3, sp4, sp5, sp6, sp7;
    static boolean pt0, pt1, pt2, pt3, pt4, pt5, pt6, pt7;
    static boolean pb0, pb1, pb2, pb3, pb4, pb5, pb6, pb7;
    static int pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;
    static int wp0, wp1, wp2, wp3, wp4, wp5, wp6, wp7;
    static int wd0, wd1, wd2, wd3, wd4, wd5, wd6, wd7;

    /** Initialise the strings, bitmaps and bit-masks*/
    function void init() {

	var int i,p,q;

	let sc = Array.new(32);
	let sf = Array.new(32);
	let pc = Array.new(256);
	let pf = Array.new(256);
	let stepStr = String.new(10);
	let targetStr = String.new(10);
	let text1 = " Score  ";
	let text2 = "/3  Actions  ";
	let text3 = " ";
	let screenLocation = 16384;

	// BITMAPS
	// These were generated by a Python code generator designed
	// for this project. Note that -32768 cannot be represented
	// in Jack!

	// Sight Clear
	let sc[0]=0;let sc[1]=0;
	let sc[2]=-32767-1;let sc[3]=1;
	let sc[4]=-32767-1;let sc[5]=1;
	let sc[6]=-32767-1;let sc[7]=1;
	let sc[8]=-32767-1;let sc[9]=1;
	let sc[10]=-32767-1;let sc[11]=1;
	let sc[12]=-32767-1;let sc[13]=1;
	let sc[14]=-512;let sc[15]=127;
	let sc[16]=-512;let sc[17]=127;
	let sc[18]=-32767-1;let sc[19]=1;
	let sc[20]=-32767-1;let sc[21]=1;
	let sc[22]=-32767-1;let sc[23]=1;
	let sc[24]=-32767-1;let sc[25]=1;
	let sc[26]=-32767-1;let sc[27]=1;
	let sc[28]=-32767-1;let sc[29]=1;

	// Sight Fired
	let sf[0]=0;let sf[1]=0;
	let sf[2]=-32767-1;let sf[3]=65;
	let sf[4]=-32767-1;let sf[5]=1;
	let sf[6]=-8192;let sf[7]=7;
	let sf[8]=-8192;let sf[9]=7;
	let sf[10]=-2048;let sf[11]=31;
	let sf[12]=-2048;let sf[13]=31;
	let sf[14]=-512;let sf[15]=127;
	let sf[16]=-512;let sf[17]=127;
	let sf[18]=-2048;let sf[19]=31;
	let sf[20]=-2048;let sf[21]=31;
	let sf[22]=-7168;let sf[23]=7;
	let sf[24]=-8192;let sf[25]=7;
	let sf[26]=-32767-1;let sf[27]=1;
	let sf[28]=-32767-1;let sf[29]=1;
	let sf[30]=0;let sf[31]=0;

	// Pistol Clear
	let pc[0]=0;let pc[1]=0;let pc[2]=0;let pc[3]=0;
	let pc[4]=0;let pc[5]=0;let pc[6]=0;let pc[7]=0;
	let pc[8]=0;let pc[9]=0;let pc[10]=0;let pc[11]=0;
	let pc[12]=0;let pc[13]=0;let pc[14]=0;let pc[15]=0;
	let pc[16]=-16384;let pc[17]=0;let pc[18]=0;let pc[19]=0;
	let pc[20]=-16384;let pc[21]=0;let pc[22]=0;let pc[23]=0;
	let pc[24]=-4096;let pc[25]=15;let pc[26]=0;let pc[27]=0;
	let pc[28]=-4096;let pc[29]=15;let pc[30]=0;let pc[31]=0;
	let pc[32]=-1024;let pc[33]=63;let pc[34]=0;let pc[35]=0;
	let pc[36]=-1024;let pc[37]=63;let pc[38]=0;let pc[39]=0;
	let pc[40]=-1024;let pc[41]=255;let pc[42]=0;let pc[43]=0;
	let pc[44]=-1024;let pc[45]=255;let pc[46]=0;let pc[47]=0;
	let pc[48]=-1024;let pc[49]=1023;let pc[50]=0;let pc[51]=0;
	let pc[52]=-1024;let pc[53]=1023;let pc[54]=0;let pc[55]=0;
	let pc[56]=-4096;let pc[57]=4095;let pc[58]=0;let pc[59]=0;
	let pc[60]=-4096;let pc[61]=4095;let pc[62]=0;let pc[63]=0;
	let pc[64]=-16384;let pc[65]=-1;let pc[66]=0;let pc[67]=0;
	let pc[68]=-16384;let pc[69]=-1;let pc[70]=0;let pc[71]=0;
	let pc[72]=0;let pc[73]=-1;let pc[74]=3;let pc[75]=0;
	let pc[76]=0;let pc[77]=-1;let pc[78]=3;let pc[79]=0;
	let pc[80]=0;let pc[81]=-1;let pc[82]=15;let pc[83]=0;
	let pc[84]=0;let pc[85]=-1;let pc[86]=15;let pc[87]=0;
	let pc[88]=0;let pc[89]=-1;let pc[90]=63;let pc[91]=0;
	let pc[92]=0;let pc[93]=-1;let pc[94]=63;let pc[95]=0;
	let pc[96]=0;let pc[97]=16383;let pc[98]=780;let pc[99]=0;
	let pc[100]=0;let pc[101]=16383;let pc[102]=780;let pc[103]=0;
	let pc[104]=0;let pc[105]=16332;let pc[106]=768;let pc[107]=0;
	let pc[108]=0;let pc[109]=16332;let pc[110]=768;let pc[111]=0;
	let pc[112]=0;let pc[113]=-196;let pc[114]=4095;let pc[115]=0;
	let pc[116]=0;let pc[117]=-196;let pc[118]=4095;let pc[119]=0;
	let pc[120]=0;let pc[121]=-784;let pc[122]=4095;let pc[123]=0;
	let pc[124]=0;let pc[125]=-784;let pc[126]=4095;let pc[127]=0;
	let pc[128]=0;let pc[129]=-16;let pc[130]=4095;let pc[131]=0;
	let pc[132]=0;let pc[133]=-16;let pc[134]=4095;let pc[135]=0;
	let pc[136]=0;let pc[137]=-16;let pc[138]=4095;let pc[139]=0;
	let pc[140]=0;let pc[141]=-16;let pc[142]=4095;let pc[143]=0;
	let pc[144]=0;let pc[145]=-16;let pc[146]=-1;let pc[147]=0;
	let pc[148]=0;let pc[149]=-16;let pc[150]=-1;let pc[151]=0;
	let pc[152]=0;let pc[153]=-16;let pc[154]=16383;let pc[155]=15;
	let pc[156]=0;let pc[157]=-16;let pc[158]=16383;let pc[159]=15;
	let pc[160]=0;let pc[161]=-64;let pc[162]=16383;let pc[163]=48;
	let pc[164]=0;let pc[165]=-64;let pc[166]=16383;let pc[167]=48;
	let pc[168]=0;let pc[169]=-4;let pc[170]=16383;let pc[171]=192;
	let pc[172]=0;let pc[173]=-4;let pc[174]=16383;let pc[175]=192;
	let pc[176]=0;let pc[177]=-49;let pc[178]=16383;let pc[179]=192;
	let pc[180]=0;let pc[181]=-49;let pc[182]=16383;let pc[183]=192;
	let pc[184]=0;let pc[185]=-973;let pc[186]=16383;let pc[187]=768;
	let pc[188]=0;let pc[189]=-973;let pc[190]=16383;let pc[191]=768;
	let pc[192]=0;let pc[193]=-4045;let pc[194]=16383;let pc[195]=3072;
	let pc[196]=0;let pc[197]=-4045;let pc[198]=16383;let pc[199]=3072;
	let pc[200]=0;let pc[201]=-16333;let pc[202]=4095;let pc[203]=3072;
	let pc[204]=0;let pc[205]=-16333;let pc[206]=4095;let pc[207]=3072;
	let pc[208]=0;let pc[209]=12;let pc[210]=1023;let pc[211]=12288;
	let pc[212]=0;let pc[213]=12;let pc[214]=1023;let pc[215]=12288;
	let pc[216]=0;let pc[217]=12;let pc[218]=1020;let pc[219]=12288;
	let pc[220]=0;let pc[221]=12;let pc[222]=1020;let pc[223]=12288;
	let pc[224]=0;let pc[225]=48;let pc[226]=48;let pc[227]=12288;
	let pc[228]=0;let pc[229]=48;let pc[230]=48;let pc[231]=12288;
	let pc[232]=0;let pc[233]=192;let pc[234]=0;let pc[235]=12288;
	let pc[236]=0;let pc[237]=192;let pc[238]=0;let pc[239]=12288;
	let pc[240]=0;let pc[241]=768;let pc[242]=0;let pc[243]=12288;
	let pc[244]=0;let pc[245]=768;let pc[246]=0;let pc[247]=12288;
	let pc[248]=0;let pc[249]=3072;let pc[250]=0;let pc[251]=12288;
	let pc[252]=0;let pc[253]=3072;let pc[254]=0;let pc[255]=12288;

	// Pistol Fired
	let pf[0]=-64;let pf[1]=255;let pf[2]=0;let pf[3]=0;
	let pf[4]=-64;let pf[5]=255;let pf[6]=0;let pf[7]=0;
	let pf[8]=-784;let pf[9]=1023;let pf[10]=0;let pf[11]=0;
	let pf[12]=-784;let pf[13]=1023;let pf[14]=0;let pf[15]=0;
	let pf[16]=-16;let pf[17]=831;let pf[18]=0;let pf[19]=0;
	let pf[20]=-16;let pf[21]=831;let pf[22]=0;let pf[23]=0;
	let pf[24]=-16;let pf[25]=1023;let pf[26]=0;let pf[27]=0;
	let pf[28]=-16;let pf[29]=1023;let pf[30]=0;let pf[31]=0;
	let pf[32]=-208;let pf[33]=255;let pf[34]=0;let pf[35]=0;
	let pf[36]=-208;let pf[37]=255;let pf[38]=0;let pf[39]=0;
	let pf[40]=-16;let pf[41]=255;let pf[42]=0;let pf[43]=0;
	let pf[44]=-16;let pf[45]=255;let pf[46]=0;let pf[47]=0;
	let pf[48]=-64;let pf[49]=1023;let pf[50]=0;let pf[51]=0;
	let pf[52]=-64;let pf[53]=1023;let pf[54]=0;let pf[55]=0;
	let pf[56]=-4096;let pf[57]=4095;let pf[58]=0;let pf[59]=0;
	let pf[60]=-4096;let pf[61]=4095;let pf[62]=0;let pf[63]=0;
	let pf[64]=-16384;let pf[65]=-1;let pf[66]=0;let pf[67]=0;
	let pf[68]=-16384;let pf[69]=-1;let pf[70]=0;let pf[71]=0;
	let pf[72]=0;let pf[73]=-1;let pf[74]=3;let pf[75]=0;
	let pf[76]=0;let pf[77]=-1;let pf[78]=3;let pf[79]=0;
	let pf[80]=0;let pf[81]=-1;let pf[82]=15;let pf[83]=0;
	let pf[84]=0;let pf[85]=-1;let pf[86]=15;let pf[87]=0;
	let pf[88]=0;let pf[89]=-1;let pf[90]=63;let pf[91]=0;
	let pf[92]=0;let pf[93]=-1;let pf[94]=63;let pf[95]=0;
	let pf[96]=0;let pf[97]=16383;let pf[98]=780;let pf[99]=0;
	let pf[100]=0;let pf[101]=16383;let pf[102]=780;let pf[103]=0;
	let pf[104]=0;let pf[105]=16332;let pf[106]=768;let pf[107]=0;
	let pf[108]=0;let pf[109]=16332;let pf[110]=768;let pf[111]=0;
	let pf[112]=0;let pf[113]=-196;let pf[114]=4095;let pf[115]=0;
	let pf[116]=0;let pf[117]=-196;let pf[118]=4095;let pf[119]=0;
	let pf[120]=0;let pf[121]=-784;let pf[122]=4095;let pf[123]=0;
	let pf[124]=0;let pf[125]=-784;let pf[126]=4095;let pf[127]=0;
	let pf[128]=0;let pf[129]=-16;let pf[130]=4095;let pf[131]=0;
	let pf[132]=0;let pf[133]=-16;let pf[134]=4095;let pf[135]=0;
	let pf[136]=0;let pf[137]=-16;let pf[138]=4095;let pf[139]=0;
	let pf[140]=0;let pf[141]=-16;let pf[142]=4095;let pf[143]=0;
	let pf[144]=0;let pf[145]=-16;let pf[146]=-1;let pf[147]=0;
	let pf[148]=0;let pf[149]=-16;let pf[150]=-1;let pf[151]=0;
	let pf[152]=0;let pf[153]=-16;let pf[154]=16383;let pf[155]=15;
	let pf[156]=0;let pf[157]=-16;let pf[158]=16383;let pf[159]=15;
	let pf[160]=0;let pf[161]=-64;let pf[162]=16383;let pf[163]=48;
	let pf[164]=0;let pf[165]=-64;let pf[166]=16383;let pf[167]=48;
	let pf[168]=0;let pf[169]=-4;let pf[170]=16383;let pf[171]=192;
	let pf[172]=0;let pf[173]=-4;let pf[174]=16383;let pf[175]=192;
	let pf[176]=0;let pf[177]=-49;let pf[178]=16383;let pf[179]=192;
	let pf[180]=0;let pf[181]=-49;let pf[182]=16383;let pf[183]=192;
	let pf[184]=0;let pf[185]=-973;let pf[186]=16383;let pf[187]=768;
	let pf[188]=0;let pf[189]=-973;let pf[190]=16383;let pf[191]=768;
	let pf[192]=0;let pf[193]=-4045;let pf[194]=16383;let pf[195]=3072;
	let pf[196]=0;let pf[197]=-4045;let pf[198]=16383;let pf[199]=3072;
	let pf[200]=0;let pf[201]=-16333;let pf[202]=4095;let pf[203]=3072;
	let pf[204]=0;let pf[205]=-16333;let pf[206]=4095;let pf[207]=3072;
	let pf[208]=0;let pf[209]=12;let pf[210]=1023;let pf[211]=12288;
	let pf[212]=0;let pf[213]=12;let pf[214]=1023;let pf[215]=12288;
	let pf[216]=0;let pf[217]=12;let pf[218]=1020;let pf[219]=12288;
	let pf[220]=0;let pf[221]=12;let pf[222]=1020;let pf[223]=12288;
	let pf[224]=0;let pf[225]=48;let pf[226]=48;let pf[227]=12288;
	let pf[228]=0;let pf[229]=48;let pf[230]=48;let pf[231]=12288;
	let pf[232]=0;let pf[233]=192;let pf[234]=0;let pf[235]=12288;
	let pf[236]=0;let pf[237]=192;let pf[238]=0;let pf[239]=12288;
	let pf[240]=0;let pf[241]=768;let pf[242]=0;let pf[243]=12288;
	let pf[244]=0;let pf[245]=768;let pf[246]=0;let pf[247]=12288;
	let pf[248]=0;let pf[249]=3072;let pf[250]=0;let pf[251]=12288;
	let pf[252]=0;let pf[253]=3072;let pf[254]=0;let pf[255]=12288;

	// BIT MASKS
	// These simplify the maths as the Hack machine code has no
	// right-shift operator, so this avoids lots of unncessary
	// multiplications
	
	let patternMask = Array.new(16);
	let i = 0; let p = 3; let q = 1;
	while (i < 16) {
	    let patternMask[i] = q;
	    let i = i + 1;
	    let p = p + p + p + p;
	    let q = q + q;
	}

	return;
    }

    /** Accessors for the bitmaps */
    function int sc() { return sc; }
    function int sf() { return sf; }
    function int pc() { return pc; }
    function int pf() { return pf; }

    
    /** Render the number of targets hit and steps taken */
    function void scores(int targets, int steps) {

	// Display the scores
	// Must pre-initialise the text or else the OS leaks and
	// gives a heap overflow error
	do targetStr.setInt(targets);
	do stepStr.setInt(steps);
	do Output.moveCursor(0,35);
	do Output.printString(text1); /* " Score  " */
	do Output.printString(targetStr);
	do Output.printString(text2); /* "/3  Actions  " */
	do Output.printString(stepStr);
	do Output.printString(text3); /* " " */

	return;
    }

    
    /** Render a bitmap image to the screen */
    function void bitmap(int bmp, int size, int byteWidth, int screenWord) {

	var int byte;
	var int memVal;
	var int offset;
	var int width;
	
	let byte = 0;
	let offset = screenWord;
	let width = 0;

	while (byte < size) {
	    
	    // Or's the bitmap onto the screen, so does not delete the
	    // walls that have already been rendered
	    // Writes directly into screen memory
	    let memVal = screenLocation[offset];
	    let memVal = memVal | bmp[byte];
	    let screenLocation[offset] = memVal;

	    let byte = byte + 1;
	    let width = width + 1;
	    let offset = offset + 1;
	    if (width = byteWidth) {
		let offset = offset - width + 32;
		let width = 0;
	    }   
     
	}
	return;
    }

    /** Wall rendering - middle-out! */
    function void walls(int wallDistances, int wallPatterns) {

	// Rendering walls is complicated in order to avoid floating point multiplications and 
	// divisions.  8 vertical strips are rendered at the same time, with 8 sets of counters
	// keeping track of which segment to render where.
	// Because the geometry is vertically symmetrical, the renderer starts in the middle
	// and renders up and down at the same time.
	// Note that it renders in 2x2 blocks, reducing the effective resolution of
	// the screen to 256 x 128 pixels. Trying to render full resolution is MUCH
	// slower.
	// Since original version: significant (x2) speed-up through:
	// ... loop unrolling (sorry, not very good procedural code)
	// ... eliminating arrays in the loop counters (statics are faster)
	// ... direct write to screen memory (avoids function call overhead)
	// ... additional pre-calculations and hard-wire numbers (yuk, but fast)
	// Sorry! This is really obscure, but it is the single biggest bottleneck,
	// so you will have to live with some tricky math.

	var int pixel, strip, vPos;  /* which bit of the screen to render to*/
	var int lineT, memValT;      /* location and contents of word in top-half of the screen */
	var int lineB, memValB;      /* location and contents of word in bottom-half of the screen */
	var int wp;

	let strip = 0; let pixel = 0;
	
	while (strip < 32) {

	    // Set up counters for each of the 8 vertical patterns in this strip
	    let cp0 = 0; let cp1 = 0; let cp2 = 0; let cp3 = 0; let cp4 = 0; let cp5 = 0; let cp6 = 0; let cp7 = 0; 
	    let sp0 = 7; let sp1 = 7; let sp2 = 7; let sp3 = 7; let sp4 = 7; let sp5 = 7; let sp6 = 7; let sp7 = 7;
	    let pp0 = 256; let pp1 = 256; let pp2 = 256; let pp3 = 256; let pp4 = 256; let pp5 = 256; let pp6 = 256; let pp7 = 256; 
	    let wp0 = wallPatterns[pixel + 0]; let wd0 = wallDistances[pixel + 0];
	    let wp1 = wallPatterns[pixel + 1]; let wd1 = wallDistances[pixel + 1];
	    let wp2 = wallPatterns[pixel + 2]; let wd2 = wallDistances[pixel + 2];
	    let wp3 = wallPatterns[pixel + 3]; let wd3 = wallDistances[pixel + 3];
	    let wp4 = wallPatterns[pixel + 4]; let wd4 = wallDistances[pixel + 4];
	    let wp5 = wallPatterns[pixel + 5]; let wd5 = wallDistances[pixel + 5];
	    let wp6 = wallPatterns[pixel + 6]; let wd6 = wallDistances[pixel + 6];
	    let wp7 = wallPatterns[pixel + 7]; let wd7 = wallDistances[pixel + 7];
	    let pt0 = ~((wp0 & patternMask[7]) = 0);  let pb0 = ~((wp0 & patternMask[8]) = 0);
	    let pt1 = ~((wp1 & patternMask[7]) = 0);  let pb1 = ~((wp1 & patternMask[8]) = 0);
	    let pt2 = ~((wp2 & patternMask[7]) = 0);  let pb2 = ~((wp2 & patternMask[8]) = 0);
	    let pt3 = ~((wp3 & patternMask[7]) = 0);  let pb3 = ~((wp3 & patternMask[8]) = 0);
	    let pt4 = ~((wp4 & patternMask[7]) = 0);  let pb4 = ~((wp4 & patternMask[8]) = 0);
	    let pt5 = ~((wp5 & patternMask[7]) = 0);  let pb5 = ~((wp5 & patternMask[8]) = 0);
	    let pt6 = ~((wp6 & patternMask[7]) = 0);  let pb6 = ~((wp6 & patternMask[8]) = 0);
	    let pt7 = ~((wp7 & patternMask[7]) = 0);  let pb7 = ~((wp7 & patternMask[8]) = 0);

	    let lineT = 4064 + strip; /* memory location for the mid-point of this strip */
	    let lineB = 4096 + strip; /* memory location for start of bottom-half */

	    // Count which segment we are rendering and fetch the pattern value to draw
	    let vPos = 63;
	    while (vPos > -1) {
		
		let memValT = 0; let memValB = 0;

		// Pattern strip 0
		if (sp0 > -1) {
		    if (pt0) {
			let memValT = memValT + 3;
		    }
		    if (pb0) {
			let memValB = memValB + 3;
		    }
		}
		let cp0 = cp0 + wd0;
		while (cp0 > 512) {
		    let cp0 = cp0 - 512;
		    let sp0 = sp0 - 1;
		    let pp0 = pp0 + pp0;
		    let pt0 = ~((wp0 & patternMask[sp0]) = 0);
		    let pb0 = ~((wp0 & pp0) = 0);
		}

		// Pattern strip 1
		if (sp1 > -1) {
		    if (pt1) {
			let memValT = memValT + 12;
		    }
		    if (pb1) {
			let memValB = memValB + 12;
		    }
		}
		let cp1 = cp1 + wd1;
		while (cp1 > 512) {
		    let cp1 = cp1 - 512;
		    let sp1 = sp1 - 1;
		    let pp1 = pp1 + pp1;
		    let pt1 = ~((wp1 & patternMask[sp1]) = 0);
		    let pb1 = ~((wp1 & pp1) = 0);
		}

		// Pattern strip 2
		if (sp2 > -1) {
		    if (pt2) {
			let memValT = memValT + 48;
		    }
		    if (pb2) {
			let memValB = memValB + 48;
		    }
		}
		let cp2 = cp2 + wd2;
		while (cp2 > 512) {
		    let cp2 = cp2 - 512;
		    let sp2 = sp2 - 1;
		    let pp2 = pp2 + pp2;
		    let pt2 = ~((wp2 & patternMask[sp2]) = 0);
		    let pb2 = ~((wp2 & pp2) = 0);
		}

		// Pattern strip 3
		if (sp3 > -1) {
		    if (pt3) {
			let memValT = memValT + 192;
		    }
		    if (pb3) {
			let memValB = memValB + 192;
		    }
		}
		let cp3 = cp3 + wd3;
		while (cp3 > 512) {
		    let cp3 = cp3 - 512;
		    let sp3 = sp3 - 1;
		    let pp3 = pp3 + pp3;
		    let pt3 = ~((wp3 & patternMask[sp3]) = 0);
		    let pb3 = ~((wp3 & pp3) = 0);
		}

		// Pattern strip 4
		if (sp4 > -1) {
		    if (pt4) {
			let memValT = memValT + 768;
		    }
		    if (pb4) {
			let memValB = memValB + 768;
		    }
		}
		let cp4 = cp4 + wd4;
		while (cp4 > 512) {
		    let cp4 = cp4 - 512;
		    let sp4 = sp4 - 1;
		    let pp4 = pp4 + pp4;
		    let pt4 = ~((wp4 & patternMask[sp4]) = 0);
		    let pb4 = ~((wp4 & pp4) = 0);
		}

		// Pattern strip 5
		if (sp5 > -1) {
		    if (pt5) {
			let memValT = memValT + 3072;
		    }
		    if (pb5) {
			let memValB = memValB + 3072;
		    }
		}
		let cp5 = cp5 + wd5;
		while (cp5 > 512) {
		    let cp5 = cp5 - 512;
		    let sp5 = sp5 - 1;
		    let pp5 = pp5 + pp5;
		    let pt5 = ~((wp5 & patternMask[sp5]) = 0);
		    let pb5 = ~((wp5 & pp5) = 0);
		}

		// Pattern strip 6
		if (sp6 > -1) {
		    if (pt6) {
			let memValT = memValT + 12288;
		    }
		    if (pb6) {
			let memValB = memValB + 12288;
		    }
		}
		let cp6 = cp6 + wd6;
		while (cp6 > 512) {
		    let cp6 = cp6 - 512;
		    let sp6 = sp6 - 1;
		    let pp6 = pp6 + pp6;
		    let pt6 = ~((wp6 & patternMask[sp6]) = 0);
		    let pb6 = ~((wp6 & pp6) = 0);
		}

		// Pattern strip 7
		if (sp7 > -1) {
		    if (pt7) {
			let memValT = memValT - 16384;
		    }
		    if (pb7) {
			let memValB = memValB - 16384;
		    }
		}
		let cp7 = cp7 + wd7;
		while (cp7 > 512) {
		    let cp7 = cp7 - 512;
		    let sp7 = sp7 - 1;
		    let pp7 = pp7 + pp7;
		    let pt7 = ~((wp7 & patternMask[sp7]) = 0);
		    let pb7 = ~((wp7 & pp7) = 0);
		}		

		// Draw the pixel values for the words in top and bottom half
		// by writing directly into the screen memory. Since the resolution
		// in the game is half the screen resolution we have to write each
		// value twice for each of the top and bottom halves.
		let screenLocation[lineT] = memValT;
		let screenLocation[lineB] = memValB;
		let lineT = lineT - 32; let lineB = lineB + 32;
		let screenLocation[lineT] = memValT;
		let screenLocation[lineB] = memValB;
		let lineT = lineT - 32; let lineB = lineB + 32;

		let vPos = vPos - 1;
	    } // END WHILE (vPos)
	    
	    let strip = strip + 1;
	    let pixel = pixel + 8;
	} // END WHILE (strip)

	return;
    }

    /** Render the splash screen at the end of the game */
    function void splash_screen(String line1, String line2) {

	var char key;
	
	// Clear the screen
	do Screen.clearScreen();

	// Display the text in the middle of the screen
	do Output.moveCursor(10, 25);
	do Output.printString(line1);
	do Output.moveCursor(11, 25);
	do Output.printString(line2);

	// Display credits
	do Output.moveCursor(21, 40);
	do Output.printString("James Leibert 2017");

	// Wait for a key press to finish
	while (key = 0) {
	    let key = Keyboard.keyPressed();
	}

	// Finish
	return;
	
    }


    /** Cleans up the static arrays and strings */
    function void cleanup() {
	do sc.dispose();
	do sf.dispose();
	do pc.dispose();
	do pf.dispose();
	do patternMask.dispose();
	do stepStr.dispose();
	do targetStr.dispose();
	return;
    }


    
}
